Security should not be an afterthought or add-on. – Identify relevant security requirements and treat them in the  overall process and system design . – Identifying relevant security  requirements and treating them as  policies as a foundation for your design .

Concept: No absolute security; balance is key . Practical Approach: Align security level with asset value . Principle of Least Privilege: Minimal rights for tasks . Reduces system vulnerability and damage .

Analogy: Castle defenses - multiple layers for robust  protections . Software Application: Combine diverse security  measures for comprehensive defense . Objective: Prevent system abuse and  ensure comprehensive  oversight .

The concept was suggested by E. Glaser in 1965 . The default situation is lack of access, and the protection  scheme identifies conditions under which access is permitted .

The likelihood of vulnerabilities increases with the complexity of software architectural design and code . The attack surface of the software is reduced by keeping the design and implementation details simple and understandable .

A security principle that ensures that authority is not . not .circumvented in subsequent requests of an object by a                 subject, by checking for authorization (rights and privileges) upon every request for the object . Open design is  more effective than hiding mechanisms .

Least Common Mechanism: Avoid shared mechanisms to minimize information leaks . Balance: Specialized processes vs. shared ones . Focus: User-friendly and unobtrusive security . Consideration: Weighing component reuse against the need for segregation .

The Weakest Link: Strength  is determined by the weakest  component . Challenge: Security that doesn't hinder user efficiency . Encouraging user compliance without compromising security . Application: Include diverse  defenses to fortify the system .

Aims to minimize attack surface by minimizing vulnerabilities . Existing components are more likely to be tried and tested, and hence more secure . Components developed within the open-source community are therefore even more secure.

Avoiding Single Points of Failure: Design that withstands individual component components . Strategy: Analyze and mitigate singular failure points . Objective: Ensure redundancy and resilience in system . Comprehensive, deliberate design  for robust system security .

After a method throws an exception, the runtime system attempts to find  something to handle it . The list of methods is known as the call stack . The first method called has  the exception handler .

The most common use for a finally block is to close resources that were created inside the try block . The search for a handler is done in order that the function was called .

The ideal place to close those streams is NOT at the end of your try block, since if an exception is generated,  control will never get as far as that point . The heading of a catch block specifies the type of  exception it handles .

If you catch the Exception class first (as opposed to one of its subclasses), that block will always get executed . If an exception is UN-checked, you are NOT required to place it inside a try/catch block and handle it . An unchecked exception is one that you are not required to provide for .

A checked exception is one that the compiler requires you to provide for; that is, you must notify Java that you are aware that this exception might occur and that somewhere in your code, you are going to handle it . For example, the nextInt() method of the Scanner class throws un-proclaimed exceptions which is why we haven’t had to write code to handle them .

The compiler requires you to anticipate checked exceptions . It does so by enforcing a “catch or declare requirement” for checked exceptions . The throws clause is part of your method signature .

Only exceptions that inherit from this class are the only kinds of exceptions that do NOT have be enclosed in a try block . If you write code that invokes a method that can generate an exception must be caught. If you neglect to do this, your program won’t compile .

All exceptions that are not subclasses of type RuntimeException must be checked (placed inside  a try block) or thrown . Subclasses of RuntimeException are unchecked .

Exceptions are for unavoidable situations that can cause programs to malfunction, but for which you cannot control for, such as bad user input . Exceptions should not be used to deal with array boundaries – those are things the programmer should avoid  with proper testing . If your code does not include exception handling, a single error could bring down the entire system .

Try blocks should ideally encompass operations that are intended to be completed in full . If an exception interrupts this process, it is  advised to reset the state to what it was before .

Merely catching an exception without addressing the underlying issue can lead to unstable states or hidden bugs in your application . When considering a retry after an exception, be cautious to avoid  leaving unnecessary allocations in place . Exercise caution with any code within a catch block that might itself cause an exception .

Systems under development often contain extensive debugging output . If this is not completely removed or deactivated in production systems, it can result in significant unintended information disclosure . Logging or error messages that are publicly visible might disclose  sensitive data .

Use Exceptions for Problem Notification: Alert the calling code of  problems through exceptions rather than ad hoc methods . Implement Appropriate Exception Handling: When calling methods might throw exceptions, it's crucial to handle all possible exceptions . Prioritize addressing  specific exceptions over general, abstract handling .

Anticipating specific problems, like null pointer or I/O errors, enables the code to take more accurate and effective remedial actions . The same type of exception might occur at multiple points .

Exceptions typically signal significant issues . Ignoring an exception conceals the problem from all  higher-level callers in the stack . Recovery or Rethrow Strategy: Either handle the error gracefully and recover from it .

In Java, long-lived services that are intended to run continuously should have a strategy for handling exceptions that might not be foreseen during development . The advice is to place these general exception catch blocks at a high level in the code, typically at the  boundaries of the system where requests are processed .

By catching general exceptions, the service can avoid crashing due to unexpected errors . This is crucial for services that need to  maintain high availability . Error Reporting and Recovery can help catch errors and report them to the client .

In Java, this might look like a try-catch block around  the main request processing logic in your service . It is crucial to avoid  including data values in logs unless you are certain that they are not sensitive .

Avoid logging Stack Traces and Configuration Data as these often contain sensitive information . This is particularly important in general-purpose code, which may process various types of data .

Use of other compliant  compliant logging mechanisms, such as log4j, is also permitted . The ERR02-J.+Prevent+exceptions+while+logging+data can be used to prevent exceptions while logging .

A method that throws a NullPointerException without a null check must provide a precondition that the argument being passed to it  is not null . Omitting the null check means that the program fails more quickly  than if the program had returned false .

The solution to this security vulnerability is straightforward:  simply reset the loggedIn flag to false in the event of any exception . The true value of the loggedIn flag is returned, access is granted login access . The attacker can log in successfully bypassing the need for a valid password by triggering the exception .

In production environment, applications should never display stack traces or internal states through error messages or logs . In production setting, username/password information is highly sensitive and should be handled with utmost care .

A practical solution: to establish a secondary, secure logging repository . This repository should be accessible only to those with administrator privileges or under similar strict access controls .

Using sequential numbers could inadvertently reveal the frequency of errors – not a major security breach, but even this small insight could assist an attacker in understanding the system's operations . It is important to use unpredictable and arbitrary identifiers as reference IDs .

The OWASP Principles of Security and the Sun’s Java Tutorial, Exceptions Chapter 1, are excellent references for learning exceptions in Java . Seacord, Robert C. Secure Coding in C and C++.

